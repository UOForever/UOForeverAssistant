using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;

namespace RazorEnhanced
{
    #region Doc JSON Object

    /// <summary>
    /// DocContainer is the root container of the JSON API file, used for (de)serialization.
    /// </summary>
    [Serializable]
    class DocContainer
    {
        public DocSettings settings = new DocSettings();

        public List<DocClass> classes = new List<DocClass>();
        public List<DocMethod> constructors = new List<DocMethod>();
        public List<DocProperty> properties = new List<DocProperty>();
        public List<DocMethod> methods = new List<DocMethod>();

        public void AddRange(DocContainer otherContainer)
        {
            classes.AddRange(otherContainer.classes);
            constructors.AddRange(otherContainer.constructors);
            methods.AddRange(otherContainer.methods);
            properties.AddRange(otherContainer.properties);
        }
    }

    [Serializable]
    class DocSettings
    {
        public string version = AutoDoc.GetAssemblyVersion();
        public string baseName = "RazorEnhanced.";
    }


    [Serializable]
    class DocItem
    {
        public const String KindItem = "item";      // Generic or Unkown (TODO: Make it sensible)
        public const String KindClass = "class";      // Generic or Unkown (TODO: Make it sensible)
        public const String KindMethod = "method";
        public const String KindProperty = "property";
        public const String KindConstructor = "constructor";

        public String xmlKey;
        public String itemKind;
        public String itemClass;
        public String itemName;
        public String itemDescription;
        public bool flagAutocomplete = false;

        public DocItem(String xmlKey, String className, String propertyName, String description)
        {
            this.xmlKey = xmlKey;
            this.itemKind = DocItem.KindItem;
            this.itemClass = className;
            this.itemName = propertyName;
            this.itemDescription = description;
        }
    }

    [Serializable]
    class DocClass : DocItem
    {
        public DocClass(String xmlKey, String className, String description) : base(xmlKey, className, className, description)
        {
            this.itemKind = DocItem.KindClass;
        }
    }

    [Serializable]
    class DocProperty : DocItem
    {
        public String propertyType;
        public bool isStatic;
        public DocProperty(String xmlKey, String className, String propertyName, String propertyType, String description, bool isStatic) : base(xmlKey, className, propertyName, description)
        {
            this.itemKind = DocItem.KindProperty;
            this.propertyType = propertyType;
            this.isStatic = isStatic;
        }
    }

    [Serializable]
    class DocMethod : DocItem
    {
        public String returnType;
        public String returnDesc;
        public List<DocMethodParam> paramList;
        public bool isStatic;

        public DocMethod(String xmlKey, String className, String methodName, String returnType, String returnDesc, String description, List<DocMethodParam> paramList, bool isStatic) : base(xmlKey, className, methodName, description)
        {
            this.itemKind = DocItem.KindMethod;
            this.returnType = returnType;
            this.returnDesc = returnDesc;
            this.paramList = paramList;
            this.isStatic = isStatic;
        }
    }

    [Serializable]
    class DocMethodParam
    {
        public String itemName;
        public String itemType;
        public Boolean itemHasDefault;
        public String itemDefaultValue;
        public String itemDescription;

        public DocMethodParam(String paramName, String paramType, String description, Boolean hasDefault = false, String defaultValue = null)
        {
            this.itemName = paramName;
            this.itemType = paramType;
            this.itemHasDefault = hasDefault;
            this.itemDefaultValue = defaultValue;
            this.itemDescription = description;
        }
    }
    #endregion


    /// <summary>.
    /// This class provides various methods to Import and Export the API generated by AutoDoc.
    /// </summary>
    class AutoDocIO
    {
        public const String DEFAULT_JSON_PATH = "Config/AutoComplete.json";
        public const String DEFAULT_PY_PATH = "Config/AutoComplete.py";
        public const String DEFAULT_HTML_PATH = "./Docs/HTML/";
        public const String DEFAULT_MD_PATH = "./Docs/";
        public const String DEFAULT_SPHINX_PATH = "./Docs/Sphinx/";

        public static bool JsonDocExists(string path = null)
        {
            if (path == null) { path = DEFAULT_JSON_PATH; }
            return Exists(path);
        }

        public static bool UpdateDocs(bool update = false)
        {
            //TODO: Remove manual override
            update = true;

            if (!JsonDocExists())
            {
                update = true;
            }
            else {
                var docs = AutoDoc.GetPythonAPI(useCache: !update);
                if (!AutoDoc.MatchAssemblyVersion(docs))
                {
                    update = true;
                }

            }

            if (update) { 
                ExportPythonAPI();
                ExportPy();
            }
            
            return update;
        }

        public static bool Exists(string path)
        {
            var fullpath = Path.Combine(Assistant.Engine.RootPath, path);
            return File.Exists(fullpath);
        }


        public static void WriteAllText(string path, string contents)
        {
            var fullpath = Path.Combine(Assistant.Engine.RootPath, path);
            File.WriteAllText(fullpath, contents);
        }

        public static string ReadAllText(string path)
        {
            var fullpath = Path.Combine(Assistant.Engine.RootPath, path);
            return File.ReadAllText(fullpath);
        }


        /// <summary>
        /// Export the RE Python API list to disk using in JSON.
        /// </summary>
        /// <param name="path">Define the output path</param>
        /// <param name="pretty">Output readable JSON (Default: True)</param>
        public static void ExportPythonAPI(string path = null, bool pretty = true)
        {
            if (path == null) { path = DEFAULT_JSON_PATH; }

            String json_txt;

            DocContainer docs = AutoDoc.GetPythonAPI(false);
            if (pretty)
            {
                var options = new JsonSerializerSettings();
                options.Formatting = Newtonsoft.Json.Formatting.Indented;
                json_txt = JsonConvert.SerializeObject(docs, options);
            }
            else
            {
                json_txt = JsonConvert.SerializeObject(docs);
            }
            WriteAllText(path, json_txt);
        }

        public static DocContainer ImportPythonAPI(string path = null)
        {
            if (path == null) {
            }

            var json_txt = ReadAllText(DEFAULT_JSON_PATH);
            return JsonConvert.DeserializeObject<DocContainer>(json_txt);
        }


        private static String IDT(int num) { return new String('\t', num); }
        private static readonly string Q3 = "\"\"\"";
        private static readonly Regex NL = new Regex("\n[ \t]*", RegexOptions.Multiline | RegexOptions.Compiled);
        private static string IndentText(string IDT, string text) { return NL.Replace(text, "\n" + IDT); }

        private static string ReplacePythonTypes(string typeName, bool addQuotes=false) {
            switch (typeName) {
                case "null": return "None";
                case "String": return "str";
                case "Boolean": return "bool";
                case "Object": return "object";

                //int
                case "Byte": 
                case "Int":
                case "Int32": return "int";
                //float
                case "Float":
                case "Single": 
                case "Double": return "float";

            }
            if (addQuotes) { return '"' + typeName + '"'; }
            return typeName;
        }

        public static void ExportPy(string path = null)
        {
            // format reference:
            // https://www.sphinx-doc.org/en/master/usage/extensions/example_numpy.html#example-numpy
            // even better:
            // https://thomas-cokelaer.info/tutorials/sphinx/docstring_python.html

            if (path == null) { path = DEFAULT_PY_PATH; }
            var docs = AutoDoc.GetPythonAPI();

            List<DocClass> classList = docs.classes;
            classList.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
            List<DocProperty> propsList = docs.properties;
            propsList.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
            List<DocMethod> methodList = docs.methods;
            methodList.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));

            String content;

            var header = Q3 + $" Version: { AutoDoc.GetAssemblyVersion() }\n";
            header += "This module represents the scripting PythonAPI available in RazorEnhanced.\n";
            header += "This class is NOT intended to be used as code, but to provice autocomplete in external editors and generation documentation.\n";
            header += Q3 + "\n";
            header += "from typing import *\n";

            // header += "from System.Collections.Generic import List\n";
            // header += "from System import Byte, Int32\n";
            
        

            //Or should i replace with "python types" ? 
            header += "class String(str): pass\n";
            // header += "class List(list): pass\n";
            // header += "class Dictionary(dict): pass\n";
            header += "class Object: pass\n";


            header += "class Boolean: pass\n";
            header += "class Byte(int): pass\n";
            header += "class Int(int): pass \n";
            header += "class Int32(int): pass \n";
            header += "class UInt32(int): pass\n";
            header += "class Float(float): pass\n";
            header += "class Single(float): pass\n";
            header += "class Double(float): pass\n";





            header += "\n";

            var classListPy = new List<String>();
            // Create per-class docs
            foreach (var cls in classList)
            {
                var classFullName = cls.itemClass;
                var classTree = cls.itemClass.Split('.');
                var className = classTree.Last();
                var classDescription = cls.itemDescription;

                var depth = classTree.Length;
                var IDT0 = IDT(depth - 1);
                var IDT1 = IDT(depth);
                var IDT2 = IDT(depth + 1);
                var IDT3 = IDT(depth + 2);

                var classProps = propsList.FindAll(doc => doc.itemClass == classFullName);
                var classMethod = methodList.FindAll(doc => doc.itemClass == classFullName);



                //! Sort A-Z 
                classProps.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
                classMethod.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
                var classMethodNames = classMethod.Select(method => method.itemName).Distinct().ToList();


                // Get props
                // turn every property and field into a 
                var propsListPy = new List<string>();
                foreach (DocProperty prop in classProps)
                {
                    string propName;
                    //Docscring only
                    

                    string propDescription = IndentText(IDT2, prop.itemDescription);
                    var propType = ReplacePythonTypes(prop.propertyType,true);

                    //Property + Docstrings
                    propName  = $"{IDT1}@property\n";
                    propName += $"{IDT1}def {prop.itemName}(self) -> {propType}: ";
                    if (propDescription.Trim().Length > 0)
                    {
                        propName += $"\n{IDT2}{Q3}{propDescription}{Q3}";
                        propName += $"\n{IDT2}";
                    }
                    propName += $"return {propType.Trim('"')}() \n";
                    

                    propName += $"{IDT1}\n";
                    propName += $"{IDT1}@{prop.itemName}.setter\n";
                    propName += $"{IDT1}def {prop.itemName}(self, {prop.itemName}: {propType}): pass\n";
                    propsListPy.Add(propName);
                }

                // Get methods
                var methodListPy = new List<string>();
                

                //foreach (DocMethod method in classMethod)
                foreach (string methodName in classMethodNames)
                {

                    var sameNameMethods = classMethod.Where(method => method.itemName == methodName).OrderByDescending(method => method.paramList.Count());
                    var firstMethod = sameNameMethods.First();
                    var isStaticMethod = firstMethod.isStatic;
                    var methodParamsTypes = AutoDoc.GetMethodAllParamsTypes(classFullName, methodName);
                    var methodParamsDescs = AutoDoc.GetMethodAllParamsDescs(classFullName, methodName);
                    var methodDescs = sameNameMethods.Select((method => method.itemDescription)).Distinct().ToList();
                    var returnTypes = sameNameMethods.Select(method => method.returnType).Where(returnType => returnType != "Void").Distinct().ToList();
                    var returnDescs = sameNameMethods.Select((method => method.returnDesc)).Distinct().ToList();

                    //Build method params: Signature + Docstring
                    var methodParamsSign = new List<string>();
                    var methodParamsDocs = new List<string>();
                    foreach (var paramName in methodParamsTypes) {
                        //Signature
                        var methodParam = paramName.Key + ": ";
                        var paramsTypes = paramName.Value;
                        var paramsSignTypes = paramsTypes.Select((typeName) => ReplacePythonTypes(typeName,true)).ToList();
                        if (paramsTypes.Count() == 1)
                        {
                            methodParam += paramsSignTypes.First();
                        }
                        else {
                            methodParam += $"Union[{ String.Join(", ", paramsSignTypes) }]";
                        }
                        methodParamsSign.Add(methodParam);

                        //Docs
                        string paramDocs;
                        var paramsDocTypes = paramsTypes.Select((typeName) => ReplacePythonTypes(typeName)).ToList();
                        var paramDesc = methodParamsDescs[paramName.Key];
                        var paramDescs = String.Join("\n", paramDesc).Trim();
                        paramDocs  = $"{IDT2}{paramName.Key}: {String.Join(" or ", paramsDocTypes)}";
                        if (paramDescs.Length > 0) { 
                            paramDocs += $"\n{IDT3}{IndentText(IDT3, paramDescs)}";
                        }
                        methodParamsDocs.Add(paramDocs);
                    }


                    //Build Signature
                    if (!isStaticMethod) {
                        methodParamsSign.Insert(0, "self");
                    }
                    var methodSign = $"{methodName}({String.Join(", ", methodParamsSign)})";
                    var returnSignTypes = returnTypes.Select((returnType => ReplacePythonTypes(returnType, true))).Distinct().ToList();
                    if (returnSignTypes.Count == 1)
                    {
                        methodSign += $" -> {returnSignTypes[0]}";
                    }
                    else if (returnTypes.Count > 1)
                    {
                        methodSign += $" -> Union[{ String.Join(", ", returnSignTypes) }]";
                    }

                    //Build Doc



                    var methodPy = "";
                    if (isStaticMethod)
                    {
                        methodPy += $"{IDT1}@staticmethod\n";
                    }
                    methodPy += $"{IDT1}def {methodSign}:\n";
                    methodPy += $"{IDT2}{Q3}{ IndentText(IDT2, String.Join("\n", methodDescs) ) }\n";
                    methodPy += $"{IDT2}\n";
                    if (methodParamsDocs.Count > 0) { 
                        methodPy += $"{IDT2}Parameters\n";
                        methodPy += $"{IDT2}----------\n";
                        methodPy += $"{ String.Join("\n", methodParamsDocs) }\n";
                        methodPy += $"{IDT2}\n";
                    }

                    if (returnTypes.Count > 0)
                    {
                        methodPy += $"{IDT2}Returns\n";
                        methodPy += $"{IDT2}-------\n";
                        var returnDocTypes = returnTypes.Select((returnType => ReplacePythonTypes(returnType)));
                        methodPy += $"{IDT2}{ String.Join(", ", returnDocTypes) }\n";
                        var returnDocDescs = String.Join("\n", returnDescs).Trim();
                        if (returnDocDescs.Length > 0) { 
                            methodPy += $"{IDT3}{  IndentText(IDT3, returnDocDescs) }\n";
                        }
                        methodPy += $"{IDT2}\n";
                    }
                    methodPy += $"{IDT2}{Q3}\n";
                    //methodPy += $"{IDT2}return\n";
                    //methodPy += $"{IDT2}\n";

                    methodListPy.Add(methodPy);

                }


                // Assable page
                var classPy = "";
                classPy += $"{IDT0}class {className}:\n";
                classPy += $"{IDT1}{Q3}";
                classPy += $"{IDT1}{IndentText(IDT1, classDescription)}";
                classPy += $"{IDT1}\n";
                classPy += $"{IDT1}{Q3}\n";
                //classPy += $"{IDT1}def __init(self)__:\n";     //TODO: get contructor

                classPy += String.Join("\n", propsListPy) + "\n";
                classPy += String.Join("\n", methodListPy) + "\n";

                classListPy.Add(classPy);
            }

            var classListPyTxt = String.Join("\n", classListPy);

            content = header + classListPyTxt;
            WriteAllText(path, content);
        }





        private static readonly string html_main = @"
            <html>
                <header>
                    <link rel=stylesheet href='style.css' type='text/css'/>
                </header>
                <body>
                    {0}
                </body>
            </html>
        ";

        public static void ExportHTML(string path = null)
        {
            if (path == null) { path = DEFAULT_HTML_PATH; }
            var docs = AutoDoc.GetPythonAPI();

            List<DocClass> classList = docs.classes;
            List<DocProperty> propsList = docs.properties;
            List<DocMethod> methodList = docs.methods;

            //Sort alphabetically
            // classList.Sort( (c1,c2) => c1.itemClass.CompareTo(c2.itemClass) );
            // Create main index.html
            var classListHtml = new List<string>();
            foreach (var cls in classList)
            {
                classListHtml.Add($"<li><a href='{cls.itemClass}.html'>{cls.itemClass}</a></li>");
            }
            var menu = $"<ul>\n{String.Join("\n", classListHtml)}\n</ul>";
            Directory.CreateDirectory(path);
            WriteAllText(path + "index.html", String.Format(html_main, menu));

            // Create per-class docs
            foreach (var cls in classList)
            {
                var className = cls.itemClass;
                var classProps = propsList.FindAll(doc => doc.itemClass == className);
                var classMethod = methodList.FindAll(doc => doc.itemClass == className);

                // Sort A-Z
                classProps.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
                classMethod.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));

                // Get props
                var propsListHtml = new List<string>();
                foreach (var prop in classProps)
                {
                    var propName = $"<div class='property_name'>{className}.{prop.itemName}</div>";
                    var propDesc = $"<div class='property_desc'>{prop.itemDescription}</div>";
                    propsListHtml.Add($"{propName}\n{propDesc}\n");
                }

                // Get methods
                var methodListHtml = new List<string>();
                foreach (DocMethod method in classMethod)
                {
                    var argsSign = new List<String>();
                    var argsList = new List<String>();
                    foreach (DocMethodParam arg in method.paramList)
                    {
                        var sign = $"<div class='arg_type'>{arg.itemType}</div> <div class='arg_name'>{arg.itemName}</div>";
                        argsSign.Add(sign);
                        argsList.Add($"<li>{sign} <div class='arg_desc'>{arg.itemDescription}</div></li>");
                    }
                    var argSignHtml = $"<div class='method_arg_list'>{String.Join(", ", argsSign)}</div>";
                    var argListHtml = $"<ul>\n{String.Join("\n", argsList)}</ul>";
                    var methodName = $"<div class='method_name'>{className}.{method.itemName}({argSignHtml})</div>";
                    var methodDesc = $"<div class='method_desc'>{method.itemDescription}</div>";

                    methodListHtml.Add($"<hr/>{methodName}<br/>{argListHtml}<br/>{methodDesc}<br/>");
                }

                // Assable page
                var propsHtml = String.Join("\n", propsListHtml);
                var methodsHtml = $@"<div class='method_list'>{String.Join("\n", methodListHtml)}</div>";

                var classHtml = $@"<div class='class_name'>{className}</div>";
                var classDescHtml = $@"<div class='class_desc'>{cls.itemDescription}</div>";

                var content = $@"{classHtml}{classDescHtml}{propsHtml}{methodsHtml}";
                WriteAllText(path + className + ".html", String.Format(html_main, content));
            }
        }


        public static void ExportMKDocs(string path = null)
        {
            if (path == null) { path = DEFAULT_MD_PATH; }
            var docs = AutoDoc.GetPythonAPI();

            List<DocClass> classList = docs.classes;
            List<DocProperty> propsList = docs.properties;
            List<DocMethod> methodList = docs.methods;

            //Sort alphabetically
            //classList.Sort( (c1,c2) => c1.itemClass.CompareTo(c2.itemClass) );
            // Create main index.html
            var classListYaml = new List<string>();
            foreach (var cls in classList)
            {
                classListYaml.Add($"    - {cls.itemClass}: {cls.itemClass}.md");
            }

            String index;
            index = "site_name: Razor Enhaced\n";
            index += "docs_dir: ./MKDocs/\n";
            index += "nav:\n";
            index += "  - Classes:\n";
            index += String.Join("\n", classListYaml) + "\n";
            index += "theme:\n";
            index += "  name: readthedocs\n";
            index += "markdown_extensions:\n";
            index += "  - codehilite\n";
            // index += "      linenums: False\n";
            // index += "      use_pygments: True\n";


            Directory.CreateDirectory(path);
            Directory.CreateDirectory(path + "MKDocs/");
            WriteAllText(path + "mkdocs.yml", index);

            // Create per-class docs
            foreach (var cls in classList)
            {
                var className = cls.itemClass;
                var classProps = propsList.FindAll(doc => doc.itemClass == className);
                var classMethod = methodList.FindAll(doc => doc.itemClass == className);

                // Sort A-Z
                classProps.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
                classMethod.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));

                // Get props
                var propsListMD = new List<string>();
                foreach (DocProperty prop in classProps)
                {
                    var propName = $"### {className}.{prop.itemName} __{prop.propertyType}__";
                    var propDesc = prop.itemDescription != "" ? "\n" + prop.itemDescription : "";
                    propsListMD.Add($"{propName}{propDesc}");
                }

                // Get methods
                var methodListMD = new List<string>();
                foreach (DocMethod method in classMethod)
                {
                    var argsSign = new List<String>();
                    var argsList = new List<String>();
                    foreach (DocMethodParam arg in method.paramList)
                    {
                        var sign = $"{arg.itemName}";
                        argsSign.Add(sign);
                        argsList.Add($"- **{arg.itemName}**: {arg.itemType} {arg.itemDescription}");
                    }
                    var argListDM = $"{String.Join("\n", argsList)}";
                    var methodTitle = $"### {className}.{method.itemName}";
                    var methodName = $"```\n{className}.{method.itemName}({String.Join(", ", argsSign)}) -> {method.returnType}\n```";
                    var methodBody = $"\n{methodName}\n{argListDM}\n".Trim();
                    var methodDesc = method.itemDescription;

                    methodListMD.Add($"{methodTitle}\n{methodBody}\n{methodDesc}".Trim());
                }

                // Assable page
                var propsMD = String.Join("\n", propsListMD);
                var methodsMD = String.Join("\n", methodListMD);

                var classMD = $@"# {className}  ";
                var classDescMD = cls.itemDescription + "  \n\n";

                String content;
                content = classMD;
                content += classDescMD;
                content += $"## Properties  \n{propsMD} \n";
                content += $"## Methods  \n{methodsMD}";
                WriteAllText(path + "MKDocs/" + className + ".md", content);
            }
        }

        public static void ExportSphinx(string path = null)
        {
            if (path == null) { path = DEFAULT_SPHINX_PATH; }
            var docs = AutoDoc.GetPythonAPI();

            List<DocClass> classList = docs.classes;
            List<DocProperty> propsList = docs.properties;
            List<DocMethod> methodList = docs.methods;

            //Sort alphabetically
            //classList.Sort( (c1,c2) => c1.itemClass.CompareTo(c2.itemClass) );
            // Create main index.html
            var classListRST = new List<string>();
            foreach (var cls in classList)
            {
                classListRST.Add($"   {cls.itemClass.Replace('.', '_')}");
            }

            String index;

            index = "Python API\n";
            index += "=============\n";
            index += ".. toctree::\n";
            index += "   :maxdepth: 2\n";
            index += "   :caption: Contents:\n";
            index += "\n";
            index += String.Join("\n", classListRST) + "\n";

            /*
            index += "   /tutorials/index\n";
            index += "   /examples/index\n";
            index += "\n";
            index += "\n";
            index += "Indices and tables\n";
            index += "==================\n";

            index += "* :ref:`genindex`\n";
            index += "* :ref:`modindex`\n";
            index += "* :ref:`search`\n";
              */

            Directory.CreateDirectory(path);
            Directory.CreateDirectory(path + "api/");
            WriteAllText(path + "api/index.rst", index);

            // Create per-class docs
            foreach (var cls in classList)
            {
                var className = cls.itemClass;
                var classProps = propsList.FindAll(doc => doc.itemClass == className);
                var classMethod = methodList.FindAll(doc => doc.itemClass == className);

                // Sort A-Z
                classProps.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));
                classMethod.Sort((c1, c2) => c1.itemName.CompareTo(c2.itemName));

                // Get props
                var propsListRST = new List<string>();
                foreach (DocProperty prop in classProps)
                {
                    var propName = $"* {className}.{prop.itemName} :mod:`{prop.propertyType}`";
                    if (prop.itemDescription != "")
                    {
                        propName += $"\n  {prop.itemDescription}";
                    }
                    propsListRST.Add($"{propName}\n");
                }

                // Get methods
                var methodListRST = new List<string>();
                foreach (DocMethod method in classMethod)
                {
                    var argsSign = new List<String>();
                    var argsList = new List<String>();
                    foreach (DocMethodParam arg in method.paramList)
                    {
                        argsSign.Add($"{arg.itemName}");
                        argsList.Add($"* {arg.itemName}: :mod:`{arg.itemType}` {arg.itemDescription}");
                    }
                    var methodTitle = $"{className}.{method.itemName}";
                    var methodName = $".. py:function:: {className}.{method.itemName}({String.Join(", ", argsSign)}) -> {method.returnType}\n\n";

                    var argListDM = $"{String.Join("\n", argsList)}\n";

                    var methodBody = $"\n{methodName}\n{argListDM}\n";
                    var methodDesc = method.itemDescription;

                    methodListRST.Add($"{methodBody}\n{methodDesc}");
                    // methodListRST.Add($"{methodTitle}\n\n{methodBody}\n{methodDesc}");
                }



                // Assable page
                var classRST = $@":mod:`{className}`";


                String content;
                content = $":mod:`{className}`\n";
                content += "========================================\n";
                content += $".. py:module:: {className}\n";
                if (cls.itemDescription != "")
                {
                    content += $"   :synopsis: {cls.itemDescription}\n";
                }
                //content += $".. moduleauthor:: Bob Ippolito <bob@redivi.com>\n";
                //content += $".. sectionauthor:: Bob Ippolito <bob@redivi.com>\n";
                //content += $".. versionadded:: 2.6\n";
                content += "\n";
                content += "\n";
                if (propsListRST.Count > 0)
                {
                    var propsRST = String.Join("\n", propsListRST);
                    content += $"Properties\n----------------\n{propsRST}\n";
                }
                content += "\n";
                if (methodListRST.Count > 0)
                {
                    var methodsRST = String.Join("\n", methodListRST);
                    content += $"Methods\n--------------\n{methodsRST}\n";
                }

                WriteAllText(path + $"api/{className.Replace('.', '_')}.rst", content);
            }
        }


    }

    /// <summary>
    /// Automatically generate the full list of RE Python API using Reflection.
    /// The API is further integrated with the data coming from standard C#  comments.
    /// </summary>
    class AutoDoc
    {
        /// <summary>@nodoc</summary>
        public const String baseName = "RazorEnhanced.";
        /// <summary>@nodoc</summary>
        public const String TAG_AUTOCOMPLETE = "@autocomplete";
        /// <summary>@nodoc</summary>
        public const String TAG_NODOC = "@nodoc";
        /// <summary>@nodoc</summary>
        public const String TAG_DEPRECATE = "@deprecate";
        /// <summary>@nodoc</summary>
        public const String TAG_EXPERIMENTAL = "@experimental";
        /// <summary>@nodoc</summary>
        public const String TAG_TESTING = "@testing";
        /// <summary>@nodoc</summary>
        public const String TAG_STABLE = "@stable";

        private static DocContainer cachedDocs;

        internal static DocContainer CachedDocs
        {
            get
            {
                if (cachedDocs == null && AutoDocIO.JsonDocExists())
                {
                    cachedDocs = AutoDocIO.ImportPythonAPI();
                }
                return cachedDocs;
            }
            set => cachedDocs = value;
        }

        public static bool HasTag(string tag, string text)
        {
            return text.Contains(tag);
        }

        /// <summary>
        /// Use reflection to generete the Python API List
        /// </summary>
        public static DocContainer GetPythonAPI(bool useCache = true)
        {
           
            if (useCache && CachedDocs != null ) {
                if (MatchAssemblyVersion(CachedDocs)) {
                    return CachedDocs;
                }
            }


            Misc.SendMessage($"AutoDoc: Generating API for RE v{AutoDoc.GetAssemblyVersion()}", 70);
            var docSections = new List<Type> {
                // Test
                // typeof(AutoDoc),
                // API
                typeof(Misc),
                typeof(Misc.Context),
                typeof(Misc.MapInfo),
                typeof(Item),
                typeof(Items),
                typeof(Items.Filter),
                typeof(Mobile),
                typeof(Mobiles),
                typeof(Mobiles.TrackingInfo),
                typeof(Mobiles.Filter),
                typeof(Player),
                typeof(Spells),
                typeof(Gumps),
                typeof(Gumps.GumpData),
                typeof(Journal),
                typeof(Journal.JournalEntry),
                typeof(Target),
                typeof(Statics),
                typeof(Statics.TileInfo),

                // API Agents
                typeof(AutoLoot),
                typeof(AutoLoot.AutoLootItem),
                typeof(Scavenger),
                typeof(SellAgent),
                typeof(BuyAgent),
                typeof(Organizer),
                typeof(Dress),
                typeof(Friend),
                typeof(Restock),
                typeof(BandageHeal),
                typeof(PathFinding),
                typeof(PathFinding.Route),
                typeof(Tile),
                typeof(DPSMeter),
                typeof(Timer),
                typeof(Vendor),
                typeof(Vendor.BuyItem),

                // Other classes
                typeof(Point2D),
                typeof(Point3D),
                typeof(Property),
                typeof(HotKeyEvent)               
            };


            BindingFlags flags = BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance;
            CachedDocs = new DocContainer();

            foreach (var docSection in docSections)
            {
                var classDocs = AutoDoc.ReadClass(docSection, flags);
                CachedDocs.AddRange(classDocs);
            }

            return CachedDocs;
        }

        public static DocContainer ReadClass(Type type, BindingFlags flags)
        {
            var result = new DocContainer();

            var classKey = XMLKeyComposer.GetKey(type);
            var className = ResolveType(type);
            var classSummary = XMLCommentReader.GetDocumentation(type);
            classSummary = XMLCommentReader.RemoveBaseIndentation(classSummary);
            classSummary = XMLCommentReader.ExtractXML(classSummary, "summary");
            result.classes.Add(new DocClass(classKey, className, classSummary));


            // Methods
            var methods = type.GetMethods(flags);
            foreach (var method in methods)
            {
                // Skip: setter, getter, operator-overloader, etc
                if (method.IsSpecialName) { continue; }
                // Remove methods inherited by object, unless overwirtten
                if (method.IsDefined(typeof(Object), false)) { continue; }

                var methodKey = XMLKeyComposer.GetKey(method);
                var methodName = method.Name;
                var methodIsStatic = method.IsStatic;
                var returnType = ResolveType(method.ReturnType);
                var paramList = new List<DocMethodParam>();

                var documentation = XMLCommentReader.GetDocumentation(method);
                documentation = XMLCommentReader.RemoveBaseIndentation(documentation);
                var methodSummary = XMLCommentReader.ExtractXML(documentation, "summary");
                var returnDesc = XMLCommentReader.ExtractXML(documentation, "returns");
                if (HasTag(TAG_NODOC, methodSummary)) continue;

                var prms = method.GetParameters();
                foreach (var prm in prms)
                {

                    var paramName = prm.Name;
                    var paramType = ResolveType(prm.ParameterType);
                    var hasDefault = prm.HasDefaultValue;
                    var defaultValue = (prm.DefaultValue != null ? prm.DefaultValue.ToString() : null);
                    var paramSummary = XMLCommentReader.GetDocumentation(prm);
                    paramSummary = XMLCommentReader.RemoveBaseIndentation(paramSummary);

                    var param = new DocMethodParam(paramName, paramType, paramSummary, hasDefault, defaultValue);
                    paramList.Add(param);
                }

                var mtd = new DocMethod(methodKey, className, methodName, returnType, returnDesc, methodSummary, paramList, methodIsStatic);
                if (HasTag(TAG_AUTOCOMPLETE, methodSummary)) mtd.flagAutocomplete = true;
                result.methods.Add(mtd);
            }

            // Properties
            var props = type.GetProperties(flags);
            foreach (var prop in props)
            {
                var propKey = XMLKeyComposer.GetKey(prop);
                var itemName = prop.Name;
                var propertyType = ResolveType(prop.PropertyType);
                var propertyIsStatic = prop.IsStatic();


                var documentation = XMLCommentReader.GetDocumentation(prop);
                var propSummary = XMLCommentReader.ExtractXML(documentation, "summary");
                if (HasTag(TAG_NODOC, propSummary)) continue;

                var prt = new DocProperty(propKey, className, itemName, propertyType, propSummary, propertyIsStatic);
                result.properties.Add(prt);
            }


            // Fields
            var fields = type.GetFields(flags);
            foreach (var field in fields)
            {
                var fieldKey = XMLKeyComposer.GetKey(field);
                var itemName = field.Name;
                var fieldType = ResolveType(field.FieldType);
                var fieldIsStatic = field.IsStatic;

                var documentation = XMLCommentReader.GetDocumentation(field);
                var fieldSummary = XMLCommentReader.ExtractXML(documentation, "summary");
                if (HasTag(TAG_NODOC, fieldSummary)) continue;

                var prt = new DocProperty(fieldKey, className, itemName, fieldType, fieldSummary, fieldIsStatic);
                result.properties.Add(prt);
            }


            return result;
        }




        public static List<String> GetClasses()
        {
            var docs = GetPythonAPI();
            var names = new HashSet<String>();
            foreach (var doc in docs.classes)
            {
                names.Add(doc.itemName);
            }
            return new List<String>(names);
        }

        public static List<String> GetProperties(bool withClass = false)
        {
            var docs = GetPythonAPI();
            var names = new HashSet<String>();
            foreach (var doc in docs.properties)
            {
                names.Add(withClass ? doc.itemClass + "." + doc.itemName : doc.itemName);
            }

            return new List<String>(names);
        }

        public static Dictionary<string, List<string>> GetMethodAllParamsTypes(string className, string methodName)
        {
            var docs = GetPythonAPI();
            var sameNameMethods = docs.methods.Where((method) => method.itemClass == className && method.itemName == methodName).OrderByDescending(method => method.paramList.Count());
            var longestMethod = sameNameMethods.First();

            var result = new Dictionary<string, List<string>>();
            var argNames = longestMethod.paramList.Select((param) => param.itemName);

            int arg_num = 0;
            foreach (var argName in argNames)
            {
                var types = sameNameMethods.Select((method) => method.paramList.Count() > arg_num ? method.paramList[arg_num].itemType : "null");
                result[argName] = types.Distinct().ToList();
                arg_num++;
            }

            return result;
        }

        public static Dictionary<string, List<string>> GetMethodAllParamsDescs(string className, string methodName)
        {
            var docs = GetPythonAPI();
            var sameNameMethods = docs.methods.Where((method) => method.itemClass == className && method.itemName == methodName).OrderByDescending(method => method.paramList.Count());
            var longestMethod = sameNameMethods.First();

            var result = new Dictionary<string, List<string>>();
            var argNames = longestMethod.paramList.Select((param) => param.itemName);

            int arg_num = 0;
            foreach (var argName in argNames)
            {
                var descs = sameNameMethods.Where((method) => method.paramList.Count() > arg_num).Select((method) => method.paramList[arg_num].itemDescription);
                result[argName] = descs.Distinct().ToList();
                arg_num++;
            }

            return result;
        }


        public static List<String> GetMethods(bool withClass = false, bool withNames = false, bool withTypes = false)
        {
            var docs = GetPythonAPI();
            var names = new HashSet<String>();
            foreach (var method in docs.methods)
            {
                var signature = GetMethodSignature(method, withClass, withNames, withTypes);
                names.Add(signature);
            }
            return new List<String>(names);
        }

        public static String GetMethodSignature(DocMethod method, bool withClass = false, bool withNames = false, bool withTypes = false)
        {
            var methodName = withClass ? method.itemClass + "." + method.itemName : method.itemName;

            var signature = methodName;

            if (withTypes || withNames)
            {
                var prms = new List<String>();
                foreach (var prm in method.paramList)
                {
                    String prm_txt;
                    if (withTypes && withNames) { prm_txt = prm.itemType + " " + prm.itemName; }
                    else if (withTypes) { prm_txt = prm.itemType; }
                    else { prm_txt = prm.itemName; }
                    prms.Add(prm_txt);
                }
                signature += $"({String.Join(",", prms)})";
            }
            return signature;
        }

        public static string GetAssemblyVersion() {
            Version v = Assembly.GetCallingAssembly().GetName().Version;
            return string.Format("{0}.{1}.{2}.{3}", v.Major, v.Minor, v.Build, v.Revision);
        }

        public static bool MatchAssemblyVersion(DocContainer docs)
        {
            var current_version = GetAssemblyVersion();
            var docs_version = docs.settings.version.ToString();
            return current_version == docs_version;
        }

        public static String ResolveType(Type param)
        {
            var name = param.Name;


            if (name.StartsWith("ConcurrentDictionary"))
            {
                name = "Dictionary" + name.Substring("ConcurrentDictionary".Length);
            }


            // use names relative to baseName ( RazorEnhanced. )  
            if (param.FullName.StartsWith(baseName))
            {
                name = param.FullName;
                name = name.Replace("+", ".");
                name = name.Substring(baseName.Length);
                name = name.Replace(" ", " ");
            }

            // add 
            if (param.GenericTypeArguments.Length > 0)
            {
                name = name.Split('`')[0];
                var generics = new List<String>();
                foreach (var genericSubtype in param.GenericTypeArguments)
                {
                    //stand away citizen, recursion is here
                    generics.Add(ResolveType(genericSubtype));
                }
                name += $"[{String.Join(", ", generics)}]";
            }

            if (param.HasElementType)
            {
                // The type is either an array, pointer, or reference
                if (param.IsArray)
                {
                    // Append the "[]" array brackets onto the element type
                    name += "[]";
                }
                else if (param.IsPointer)
                {
                    // Append the "*" pointer symbol to the element type
                    name += "*";
                }
                else if (param.IsByRef)
                {
                    // Append the "@" symbol to the element type
                    name += "@";
                }
            }


            // NO NO
            else if (param.IsGenericParameter)
            {
                //TODO: do it properly ^_^
                name += "<T>";
                // Look up the index of the generic from the
                // dictionaries in Figure 5, appending "`" if
                // the parameter is from a type or "``" if the
                // parameter is from a method
            }

            return name;
        }

    }


    class XMLKeyComposer
    {
        /*
            <member name="M:RazorEnhanced.Items.Move(RazorEnhanced.Item,RazorEnhanced.Mobile,System.Int32)">
            <member name="M:RazorEnhanced.Items.Move(System.Int32,RazorEnhanced.Mobile,System.Int32)">
        */
        public static string GetKey(MethodInfo methodInfo)
        {
            var paramList = new List<String>();
            foreach (var prm in methodInfo.GetParameters())
            {
                paramList.Add(ComposeKey(prm.ParameterType.FullName, null));
            }

            string key = String.Format("M:{0}", ComposeKey(methodInfo.DeclaringType.FullName, methodInfo.Name));
            if (paramList.Count > 0) // 2 or more
            {
                key += String.Format("({0})", String.Join(",", paramList));
            }
            return key;
        }

        /*
         <member name = "T:RazorEnhanced.Items">
        </member>
        */
        public static string GetKey(ConstructorInfo constructorInfo)
        {
            var paramList = new List<String>();
            foreach (var prm in constructorInfo.GetParameters())
            {
                paramList.Add(ComposeKey(prm.ParameterType.FullName, prm.Name));
            }
            string key = String.Format("M:{0}({1})", ComposeKey(constructorInfo.DeclaringType.FullName, null), String.Join(",", paramList));
            return key;
        }

        /*
         <member name = "T:RazorEnhanced.Items"></member>
        */
        public static string GetKey(Type type)
        {
            string key = "T:" + ComposeKey(type.FullName, null);
            return key;
        }

        public static string GetKey(PropertyInfo propertyInfo)
        {
            string key = "P:" + ComposeKey(propertyInfo.DeclaringType.FullName, propertyInfo.Name);
            return key;
        }

        public static string GetKey(EventInfo eventInfo)
        {
            string key = "E:" + ComposeKey(eventInfo.DeclaringType.FullName, eventInfo.Name);
            return key;
        }

        public static string GetKey(FieldInfo fieldInfo)
        {
            string key = "F:" + ComposeKey(fieldInfo.DeclaringType.FullName, fieldInfo.Name);
            return key;
        }





        private static string ComposeKey(string typeFullNameString, string memberNameString)
        {
            string key = Regex.Replace(typeFullNameString, @"\[.*\]", string.Empty).Replace('+', '.');
            if (memberNameString != null)
            {
                key += "." + memberNameString;
            }
            return key;
        }
    }


    /// <summary>
    /// Author: Dalamar
    /// XML Comment Reader assembled following this article:
    /// https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/october/csharp-accessing-xml-documentation-via-reflection
    /// </summary>
    class XMLCommentReader
    {
        internal static HashSet<Assembly> loadedAssemblies = new HashSet<Assembly>();
        internal static Dictionary<string, string> loadedXmlDocumentation = new Dictionary<string, string>();

        public static void LoadXmlDocumentation(string xmlDocumentation)
        {
            using (XmlReader xmlReader = XmlReader.Create(new StringReader(xmlDocumentation)))
            {
                while (xmlReader.Read())
                {
                    if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name == "member")
                    {
                        string raw_name = xmlReader["name"];
                        loadedXmlDocumentation[raw_name] = xmlReader.ReadInnerXml();
                    }
                }
            }
        }

        internal static void LoadXmlDocumentation(Assembly assembly)
        {
            if (loadedAssemblies.Contains(assembly))
            {
                return; // Already loaded
            }
            string directoryPath = GetPath(assembly);
            string xmlFilePath = Path.Combine(directoryPath, assembly.GetName().Name + ".xml");
            if (File.Exists(xmlFilePath))
            {
                LoadXmlDocumentation(File.ReadAllText(xmlFilePath));
                loadedAssemblies.Add(assembly);
            }
        }

        public static string GetPath(Assembly assembly)
        {
            string codeBase = assembly.CodeBase;
            UriBuilder uri = new UriBuilder(codeBase);
            string path = Uri.UnescapeDataString(uri.Path);
            return Path.GetDirectoryName(path);
        }




        public static string GetDocumentation(MemberInfo memberInfo)
        {
            if (memberInfo.MemberType.HasFlag(MemberTypes.Field))
            {
                return GetDocumentation(((FieldInfo)memberInfo));
            }
            else if (memberInfo.MemberType.HasFlag(MemberTypes.Property))
            {
                return GetDocumentation((PropertyInfo)memberInfo);
            }
            else if (memberInfo.MemberType.HasFlag(MemberTypes.Event))
            {
                return GetDocumentation((EventInfo)memberInfo);
            }
            else if (memberInfo.MemberType.HasFlag(MemberTypes.Constructor))
            {
                return GetDocumentation((ConstructorInfo)memberInfo);
            }
            else if (memberInfo.MemberType.HasFlag(MemberTypes.Method))
            {
                return GetDocumentation((MethodInfo)memberInfo);
            }
            else if (memberInfo.MemberType.HasFlag(MemberTypes.TypeInfo) ||
                     memberInfo.MemberType.HasFlag(MemberTypes.NestedType))
            {
                return GetDocumentation((TypeInfo)memberInfo);
            }
            else
            {
                return "";
            }
        }

        public static string GetDocumentation(Type type)
        {
            LoadXmlDocumentation(type.Assembly);  //Autoload xml based.
            string key = XMLKeyComposer.GetKey(type);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }




        public static string GetDocumentation(ParameterInfo parameterInfo)
        {
            string memberDocumentation = GetDocumentation(parameterInfo.Member);
            if (memberDocumentation != "")
            {
                var name = Regex.Escape(parameterInfo.Name);
                var pattern = new Regex($"<param +name=\"{name}\">([^<]*)</param>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                Match match = pattern.Match(memberDocumentation);
                if (match.Success)
                {
                    var txt = match.Groups[1].Value;
                    return RemoveBaseIndentation(txt);
                }
            }
            return "";
        }

        private static readonly Regex baseIndent = new Regex(@"\A\n?(\s+)\S", RegexOptions.Compiled);
        public static String RemoveBaseIndentation(string text)
        {
            var match = baseIndent.Match(text);
            if (match.Success)
            {
                var padding = match.Groups[1].Value;
                text = Regex.Replace(text, $@"\n{padding}", "\n");
            }
            return text.Trim();
        }

        public static String ExtractXML(string text, string tag)
        {
            tag = Regex.Escape(tag);
            var pattern = new Regex($"<{tag}>(.*)</{tag}>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
            Match match = pattern.Match(text);
            if (match.Success)
            {
                var txt = match.Groups[1].Value;
                return RemoveBaseIndentation(txt);
            }
            return "";
        }


        /*
            <member name="M:RazorEnhanced.Items.Move(RazorEnhanced.Item,RazorEnhanced.Mobile,System.Int32)">
            <member name="M:RazorEnhanced.Items.Move(System.Int32,RazorEnhanced.Mobile,System.Int32)">
        */


        public static string GetDocumentation(MethodInfo methodInfo)
        {
            string key = XMLKeyComposer.GetKey(methodInfo);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }

        public static string GetDocumentation(ConstructorInfo constructorInfo)
        {
            string key = XMLKeyComposer.GetKey(constructorInfo);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }


        public static string GetDocumentation(PropertyInfo propertyInfo)
        {
            string key = XMLKeyComposer.GetKey(propertyInfo);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }

        public static string GetDocumentation(EventInfo eventInfo)
        {
            string key = XMLKeyComposer.GetKey(eventInfo);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }

        public static string GetDocumentation(FieldInfo fieldInfo)
        {
            string key = XMLKeyComposer.GetKey(fieldInfo);
            loadedXmlDocumentation.TryGetValue(key, out string documentation);
            return documentation ?? "";
        }



    }

    public static class PropertyInfoExtensions
    {
        public static bool IsStatic(this PropertyInfo source, bool nonPublic = false)
            => source.GetAccessors(nonPublic).Any(x => x.IsStatic);
    }


}
